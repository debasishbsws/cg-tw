package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

// Version information (set via ldflags during build)
var (
	version = "dev"
	commit  = "unknown"
	date    = "unknown"
)

// Constants for configuration defaults and file permissions
const (
	defaultVersion     = "0.0.0"
	defaultEpoch       = 0
	basePackage        = "wolfi-base"
	generatedSubdir    = "generated"
	testcasesSubdir    = "testcases"
	filePermissions    = 0644
	dirPermissions     = 0755
	yamlFileExtension  = ".yaml"
	passDirPrefix      = "pass-"
	failDirPrefix      = "fail-"
	generatedFileHeader = "# Auto-generated melange test file\n# DO NOT EDIT - Generated by pipeline-runner\n\n"
)

// TestCase represents a single test case configuration
type TestCase struct {
	Name             string     `yaml:"name"`
	Description      string     `yaml:"description"`
	Package          string     `yaml:"package"`
	Pipelines        []Pipeline `yaml:"pipelines"`
	ExpectPass       bool       `yaml:"expect_pass"`
	TestDependencies []string   `yaml:"test-dependencies,omitempty"`
}

// Validate checks if the test case has all required fields
func (tc *TestCase) Validate() error {
	if tc.Name == "" {
		return fmt.Errorf("test case missing name")
	}
	if tc.Package == "" {
		return fmt.Errorf("test case %q missing package", tc.Name)
	}
	if len(tc.Pipelines) == 0 {
		return fmt.Errorf("test case %q has no pipelines", tc.Name)
	}
	return nil
}

// Pipeline represents a pipeline configuration
type Pipeline struct {
	Uses string         `yaml:"uses"`
	With map[string]any `yaml:"with,omitempty"`
}

// TestSuite represents a test suite file
type TestSuite struct {
	Name        string     `yaml:"name"`
	Description string     `yaml:"description"`
	TestCases   []TestCase `yaml:"testcases"`
}

// Validate checks if the test suite has all required fields
func (ts *TestSuite) Validate() error {
	if ts.Name == "" {
		return fmt.Errorf("test suite missing name")
	}
	if len(ts.TestCases) == 0 {
		return fmt.Errorf("test suite %q has no test cases", ts.Name)
	}
	return nil
}

// MelangeConfig represents the generated melange configuration
type MelangeConfig struct {
	Package     Package     `yaml:"package"`
	Environment Environment `yaml:"environment"`
	Test        *TestConfig `yaml:"test,omitempty"`
}

type Package struct {
	Name        string `yaml:"name"`
	Version     string `yaml:"version"`
	Epoch       int    `yaml:"epoch"`
	Description string `yaml:"description"`
}

type Environment struct {
	Contents Contents `yaml:"contents"`
}

type Contents struct {
	Packages []string `yaml:"packages"`
}

type Step struct {
	Name string         `yaml:"name,omitempty"`
	Runs string         `yaml:"runs,omitempty"`
	Uses string         `yaml:"uses,omitempty"`
	With map[string]any `yaml:"with,omitempty"`
}

type TestConfig struct {
	Environment Environment `yaml:"environment,omitempty"`
	Pipeline    []Step      `yaml:"pipeline"`
}

// options holds command-line configuration for the test runner
type options struct {
	testDir         string   // Directory containing test case YAML files
	pipelineDir     string   // Directory containing pipeline definitions
	arch            string   // Target architecture (x86_64, aarch64)
	repositories    []string // Package repositories to use
	keyrings        []string // Keyrings for package verification
	outDir          string   // Output directory for generated configs
	appendPackages  []string // Global packages to append to all tests
	melangeBin      string   // Path to melange binary
	generateOnly    bool     // Only generate configs without running tests
	testSuite       string   // Specific test suite to run (empty = all)
	debug           bool     // Enable debug output (shows melange output)
}

// Logger provides different logging levels for output control
type Logger struct {
	debug bool
}

// Debug logs debug-level messages (only in debug mode)
func (l *Logger) Debug(format string, args ...interface{}) {
	if l.debug {
		fmt.Printf("[DEBUG] "+format+"\n", args...)
	}
}

// Info logs informational messages (always shown in normal mode)
func (l *Logger) Info(format string, args ...interface{}) {
	fmt.Printf(format+"\n", args...)
}

// Error logs error messages (always shown)
func (l *Logger) Error(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, "[ERROR] "+format+"\n", args...)
}

// newLogger creates a logger with the given debug setting
func newLogger(opts options) *Logger {
	return &Logger{
		debug: opts.debug,
	}
}

func main() {
	var opts options
	var repositories string
	var keyrings string
	var appendPackages string
	var showVersion bool

	flag.BoolVar(&showVersion, "version", false, "Show version information")
	flag.StringVar(&opts.testDir, "test-dir", "", "Directory containing test case YAML files")
	flag.StringVar(&opts.pipelineDir, "pipeline-dir", "", "Directory containing pipeline definitions")
	flag.StringVar(&opts.arch, "arch", "x86_64", "Architecture to test")
	flag.StringVar(&repositories, "repositories", "", "Comma-separated list of package repositories")
	flag.StringVar(&keyrings, "keyrings", "", "Comma-separated list of keyrings")
	flag.StringVar(&opts.outDir, "out-dir", "", "Output directory for generated melange files")
	flag.StringVar(&appendPackages, "append-packages", "", "Comma-separated list of packages to append as test-time dependencies")
	flag.StringVar(&opts.melangeBin, "melange", "melange", "Path to melange binary")
	flag.BoolVar(&opts.generateOnly, "generate-only", false, "Only generate melange configs without running tests")
	flag.StringVar(&opts.testSuite, "test-suite", "", "Run only a specific test suite (e.g., docs-pipeline)")
	flag.BoolVar(&opts.debug, "debug", false, "Enable debug output (shows melange output and internal details)")
	flag.Parse()

	if showVersion {
		fmt.Printf("pipeline-runner %s (commit: %s, built: %s)\n", version, commit, date)
		os.Exit(0)
	}

	if opts.testDir == "" {
		fmt.Fprintf(os.Stderr, "Error: --test-dir is required\n")
		flag.Usage()
		os.Exit(1)
	}

	if opts.pipelineDir == "" {
		fmt.Fprintf(os.Stderr, "Error: --pipeline-dir is required\n")
		flag.Usage()
		os.Exit(1)
	}

	if repositories != "" {
		opts.repositories = strings.Split(repositories, ",")
	}

	if keyrings != "" {
		opts.keyrings = strings.Split(keyrings, ",")
	}

	if appendPackages != "" {
		opts.appendPackages = strings.Split(appendPackages, ",")
	}

	if opts.outDir == "" {
		opts.outDir = filepath.Join(opts.testDir, generatedSubdir)
	}

	ctx := context.Background()
	logger := newLogger(opts)

	if err := run(ctx, opts, logger); err != nil {
		logger.Error("%v", err)
		os.Exit(1)
	}
}

// FailureInfo stores information about a failed test for detailed reporting
type FailureInfo struct {
	TestName   string // Name of the failed test case
	Package    string // Package being tested
	Expected   string // Expected outcome ("pass" or "fail")
	Actual     string // Actual outcome ("pass" or "fail")
	ConfigPath string // Path to generated config file for debugging
	SuiteName  string // Name of test suite for make command
	Error      error  // Underlying error if any
}

func run(ctx context.Context, opts options, logger *Logger) error {
	// Find all test case YAML files
	var testFiles []string
	var err error

	if opts.testSuite != "" {
		// Run only a specific test suite
		testFile := filepath.Join(opts.testDir, testcasesSubdir, opts.testSuite+yamlFileExtension)
		if _, err := os.Stat(testFile); os.IsNotExist(err) {
			return fmt.Errorf("test suite not found: %s", testFile)
		}
		testFiles = []string{testFile}
		logger.Info("Running single test suite: %s", opts.testSuite)
	} else {
		// Find all test case YAML files
		testFiles, err = filepath.Glob(filepath.Join(opts.testDir, testcasesSubdir, "*"+yamlFileExtension))
		if err != nil {
			return fmt.Errorf("failed to find test files: %w", err)
		}
		logger.Info("Found %d test suite files", len(testFiles))
	}

	if len(testFiles) == 0 {
		return fmt.Errorf("no test files found in %s", filepath.Join(opts.testDir, testcasesSubdir))
	}

	var totalPassed, totalFailed int
	var failures []FailureInfo

	// Process each test suite file
	for _, testFile := range testFiles {
		// Check for context cancellation
		select {
		case <-ctx.Done():
			return ctx.Err()
		default:
		}

		logger.Info("Processing test suite: %s", testFile)
		logger.Debug("Loading test suite from: %s", testFile)

		suite, err := loadTestSuite(testFile)
		if err != nil {
			return fmt.Errorf("failed to load test suite %s: %w", testFile, err)
		}

		logger.Info("Test Suite: %s", suite.Name)
		logger.Debug("Test suite has %d test cases", len(suite.TestCases))

		// Separate positive and negative test cases
		var positiveTests []TestCase
		var negativeTests []TestCase

		for _, tc := range suite.TestCases {
			if tc.ExpectPass {
				positiveTests = append(positiveTests, tc)
			} else {
				negativeTests = append(negativeTests, tc)
			}
		}

		// Generate and test positive cases (separate files in pass- directory)
		if len(positiveTests) > 0 {
			logger.Debug("Processing %d positive test cases", len(positiveTests))
			passed, failed, failureInfos, err := handleTests(ctx, suite, positiveTests, true, opts, logger)
			if err != nil {
				return err
			}
			totalPassed += passed
			totalFailed += failed
			failures = append(failures, failureInfos...)
		}

		// Generate and test negative cases (separate files in fail- directory)
		if len(negativeTests) > 0 {
			logger.Debug("Processing %d negative test cases", len(negativeTests))
			passed, failed, failureInfos, err := handleTests(ctx, suite, negativeTests, false, opts, logger)
			if err != nil {
				return err
			}
			totalPassed += passed
			totalFailed += failed
			failures = append(failures, failureInfos...)
		}
	}

	logger.Info("\n========================================")
	if opts.generateOnly {
		logger.Info("Generation Results:")
		logger.Info("  Total configs generated: %d", totalPassed+totalFailed)
		logger.Info("  Output directory: %s", opts.outDir)
	} else {
		logger.Info("Test Results:")
		logger.Info("  Passed: %d", totalPassed)
		logger.Info("  Failed: %d", totalFailed)
		logger.Info("  Total:  %d", totalPassed+totalFailed)

		if totalFailed > 0 {
			logger.Info("")
			logger.Info("Failing Test Details:")
			logger.Info("----------------------------------------")
			for i, failure := range failures {
				logger.Info("\n%d. %s", i+1, failure.TestName)
				logger.Info("   Package:  %s", failure.Package)
				logger.Info("   Expected: %s", failure.Expected)
				logger.Info("   Actual:   %s", failure.Actual)
				logger.Info("   Config:   %s", failure.ConfigPath)
				logger.Info("   Run:      make test-pipelines-autogen/%s", failure.SuiteName)
				if failure.Error != nil {
					logger.Info("   Error:    %v", failure.Error)
					logger.Debug("   Full error: %+v", failure.Error)
				}
			}
			logger.Info("")
			logger.Info("To debug failures:")
			logger.Info("  1. Check the generated config file listed above")
			logger.Info("  2. Run the specific test suite with the make command shown")
			logger.Info("  3. Run melange test directly with --debug for more details")
		}
	}
	logger.Info("========================================")

	if !opts.generateOnly && totalFailed > 0 {
		return fmt.Errorf("%d tests failed", totalFailed)
	}

	return nil
}

func handleTests(ctx context.Context, suite *TestSuite, tests []TestCase, expectPass bool, opts options, logger *Logger) (int, int, []FailureInfo, error) {
	// Create directory for tests
	var dirName string
	if expectPass {
		dirName = passDirPrefix + sanitizeFileName(suite.Name)
	} else {
		dirName = failDirPrefix + sanitizeFileName(suite.Name)
	}
	testDir := filepath.Join(opts.outDir, dirName)

	if err := os.MkdirAll(testDir, dirPermissions); err != nil {
		return 0, 0, nil, fmt.Errorf("failed to create test directory: %w", err)
	}

	passed := 0
	failed := 0
	var failures []FailureInfo

	// Generate separate file for each test case
	for _, tc := range tests {
		// Check for context cancellation
		select {
		case <-ctx.Done():
			return passed, failed, failures, ctx.Err()
		default:
		}

		pkg := tc.Package
		fileName := pkg + yamlFileExtension
		configPath := filepath.Join(testDir, fileName)

		config := generateConfig(tc, opts)

		if err := writeMelangeConfig(configPath, config); err != nil {
			return passed, failed, failures, fmt.Errorf("failed to write config: %w", err)
		}

		testType := "positive"
		if !expectPass {
			testType = "negative"
		}
		logger.Info("  ✓ Generated %s test: %s", testType, configPath)
		logger.Debug("    Package: %s, Expect pass: %v", pkg, expectPass)

		if opts.generateOnly {
			passed++
			continue
		}

		// Run melange test with test case specific dependencies
		testErr := runMelangeTest(ctx, configPath, opts, logger)

		// Check if result matches expectation
		testPassed := (testErr == nil && expectPass) || (testErr != nil && !expectPass)

		if testPassed {
			if expectPass {
				logger.Info("    ✓ PASS: %s (correctly accepted %s)", tc.Name, pkg)
			} else {
				logger.Info("    ✓ PASS: %s (correctly rejected %s)", tc.Name, pkg)
			}
			logger.Debug("    Test completed successfully")
			passed++
		} else {
			// Extract suite name from path for make command
			suiteName := extractSuiteNameFromPath(configPath)

			logger.Info("\n    ✗ FAIL: %s", tc.Name)
			logger.Info("      Package: %s", pkg)
			logger.Info("      Expected: %s", expectString(expectPass))
			logger.Info("      Actual:   %s", expectString(testErr == nil))
			logger.Info("      Config:   %s", configPath)
			logger.Info("      Run:      make test-pipelines-autogen/%s", suiteName)
			if testErr != nil && expectPass {
				logger.Info("      Error:    %v", testErr)
				logger.Debug("      Full error details: %+v", testErr)
			}
			logger.Info("")

			// Store failure info for summary
			failures = append(failures, FailureInfo{
				TestName:   tc.Name,
				Package:    pkg,
				Expected:   expectString(expectPass),
				Actual:     expectString(testErr == nil),
				ConfigPath: configPath,
				SuiteName:  suiteName,
				Error:      testErr,
			})

			failed++
		}
	}

	return passed, failed, failures, nil
}

func loadTestSuite(path string) (*TestSuite, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", path, err)
	}

	var suite TestSuite
	if err := yaml.Unmarshal(data, &suite); err != nil {
		return nil, fmt.Errorf("failed to parse YAML from %s: %w", path, err)
	}

	// Validate the suite itself
	if err := suite.Validate(); err != nil {
		return nil, fmt.Errorf("suite validation failed in %s: %w", path, err)
	}

	// Validate all test cases
	for i, tc := range suite.TestCases {
		if err := tc.Validate(); err != nil {
			return nil, fmt.Errorf("validation failed for test case %d in %s: %w", i+1, path, err)
		}
	}

	return &suite, nil
}

func generateConfig(tc TestCase, opts options) *MelangeConfig {
	var testSteps []Step
	for _, p := range tc.Pipelines {
		step := Step{
			Uses: p.Uses,
			With: p.With,
		}
		testSteps = append(testSteps, step)
	}

	// Combine global append-packages with test-specific dependencies
	// Use a map to deduplicate
	pkgMap := make(map[string]bool)
	pkgMap[basePackage] = true

	for _, pkg := range opts.appendPackages {
		pkgMap[pkg] = true
	}
	for _, pkg := range tc.TestDependencies {
		pkgMap[pkg] = true
	}

	// Convert back to slice and sort for deterministic output
	testPackages := make([]string, 0, len(pkgMap))
	for pkg := range pkgMap {
		testPackages = append(testPackages, pkg)
	}
	sort.Strings(testPackages)

	cfg := &MelangeConfig{
		Package: Package{
			Name:        tc.Package,
			Version:     defaultVersion,
			Epoch:       defaultEpoch,
			Description: tc.Description,
		},
		Environment: Environment{
			Contents: Contents{
				Packages: []string{basePackage},
			},
		},
		Test: &TestConfig{
			Environment: Environment{
				Contents: Contents{
					Packages: testPackages,
				},
			},
			Pipeline: testSteps,
		},
	}

	return cfg
}

func writeMelangeConfig(path string, cfg interface{}) error {
	data, err := yaml.Marshal(cfg)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	// Add header comment for generated files
	content := generatedFileHeader + string(data)

	if err := os.WriteFile(path, []byte(content), filePermissions); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

func runMelangeTest(ctx context.Context, configPath string, opts options, logger *Logger) error {
	// Check for context cancellation before starting
	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
	}

	args := []string{
		"test",
		"--arch", opts.arch,
		"--pipeline-dirs", opts.pipelineDir,
	}

	// Add repositories
	for _, repo := range opts.repositories {
		args = append(args, "--repository-append", repo)
	}

	// Add keyrings
	for _, keyring := range opts.keyrings {
		args = append(args, "--keyring-append", keyring)
	}

	// Add the config file
	args = append(args, configPath)

	cmd := exec.CommandContext(ctx, opts.melangeBin, args...)

	// In debug mode, show melange output in real-time
	if opts.debug {
		logger.Debug("Running melange command: %s %s", opts.melangeBin, strings.Join(args, " "))
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		return cmd.Run()
	}

	// In normal mode, capture output but don't show it
	// Only return the error - user can re-run with DEBUG=1 to see output
	_, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("melange test failed: %w", err)
	}

	return nil
}

func sanitizeFileName(name string) string {
	// Replace spaces and special characters with hyphens
	name = strings.ToLower(name)
	name = strings.ReplaceAll(name, " ", "-")
	name = strings.ReplaceAll(name, "/", "-")
	name = strings.ReplaceAll(name, ":", "-")
	name = strings.ReplaceAll(name, "(", "")
	name = strings.ReplaceAll(name, ")", "")
	return name
}

func extractSuiteNameFromPath(configPath string) string {
	// Extract suite name from path like:
	// .../generated/pass-docs-pipeline-validation-tests/bash.yaml
	// or .../generated/fail-docs-pipeline-validation-tests/bash.yaml
	// Result: docs-pipeline-validation-tests

	dir := filepath.Dir(configPath)
	dirName := filepath.Base(dir)

	// Remove pass- or fail- prefix
	if name, found := strings.CutPrefix(dirName, passDirPrefix); found {
		return name
	}
	if name, found := strings.CutPrefix(dirName, failDirPrefix); found {
		return name
	}

	return dirName
}

func expectString(pass bool) string {
	if pass {
		return "pass"
	}
	return "fail"
}
